import os
import requests
import json
import pandas as pd
import logging
import re
from io import StringIO
from typing import TypedDict, Annotated, Optional
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langchain_core.messages import BaseMessage, HumanMessage, ToolMessage, AIMessage
from pydantic import BaseModel, Field
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
import operator
from dotenv import load_dotenv
import schedule
import time
import threading
import smtplib
import ssl
from email.message import EmailMessage
from datetime import datetime, timedelta
import re
import logging
import json
import math
from enhanced_rwi import calculate_rwi

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load environment variables from .env file
load_dotenv()

# Enhanced Risk Assessment Constants
OPTIMAL = 0      # Ideal conditions for all training intensities
GOOD = 1        # Minor adjustments needed
CAUTION = 2     # Moderate risk, adjust intensity/duration
HIGH_RISK = 3   # Significant risk, easy runs only
DANGEROUS = 4   # Avoid outdoor running


# --- Reusable Email Function ---
def send_email_notification(recipient_email: str, subject: str, body: str, is_html: bool = True) -> bool:
    """Sends an email using credentials from the .env file."""
    try:
        email_user = os.getenv("EMAIL_USER")
        email_password = os.getenv("EMAIL_PASSWORD")
        email_host = os.getenv("EMAIL_HOST", "smtp.gmail.com")
        email_port = int(os.getenv("EMAIL_PORT", 587))

        if not all([email_user, email_password]):
            raise ValueError("Email credentials (EMAIL_USER, EMAIL_PASSWORD) are not set in the .env file.")

        msg = EmailMessage()
        if is_html:
            msg.set_content(body, subtype='html')
        else:
            msg.set_content(body)
            
        msg['Subject'] = subject
        msg['From'] = email_user
        msg['To'] = recipient_email

        context = ssl.create_default_context()
        with smtplib.SMTP(email_host, email_port) as server:
            server.starttls(context=context)
            server.login(email_user, email_password)
            server.send_message(msg)
        
        logger.info(f"Successfully sent email to {recipient_email}")
        return True
    except Exception as e:
        logger.error(f"Failed to send email to {recipient_email}: {e}")
        return False

# --- Helper Functions ---

def render_hour_card(hour, day_color, day_bg):
    """FIXED: Render hour card using pre-calculated final_score instead of recalculating stars."""
    
    """Render hour card with RWI-aligned color coding."""
    
    # RWI-aligned color coding based on final_score
    final_score = hour['final_score']
    
    if final_score == 5:
        score_color = "#4CAF50"  # Green - Excellent
        score_bg = "#E8F5E8"
    elif final_score == 4:
        score_color = "#8BC34A"  # Light Green - Very Good  
        score_bg = "#F1F8E9"
    elif final_score == 3:
        score_color = "#FF9800"  # Orange - Fair
        score_bg = "#FFF3E0"
    elif final_score == 2:
        score_color = "#FF5722"  # Red-Orange - Challenging
        score_bg = "#FFF3E0"
    else:  # final_score == 1
        score_color = "#F44336"  # Red - Poor
        score_bg = "#FFEBEE"
    
    # Generate star display
    filled_stars = "‚≠ê" * final_score
    empty_stars = "‚òÜ" * (5 - final_score)
    stars = filled_stars + empty_stars

    # Use the enhanced weather line formatting
    weather_details = format_weather_line_with_na(hour)
    
    # Get enhanced scientific data
    heat_stress = hour.get('heat_stress_level', 'Unknown')
    aqi_category = hour.get('aqi_category', 'Unknown')
    recommendation = hour.get('running_recommendation', 'No specific recommendation')
    
    # Add dewpoint information if available
    dewpoint_info = ""
    if hour.get('dewpoint_fahrenheit', 'N/A') != 'N/A':
        dewpoint = hour['dewpoint_fahrenheit']
        if dewpoint <= 55:
            dewpoint_color = "#4CAF50"
            dewpoint_desc = "Comfortable"
        elif dewpoint <= 65:
            dewpoint_color = "#FF9800" 
            dewpoint_desc = "Noticeable"
        else:
            dewpoint_color = "#F44336"
            dewpoint_desc = "Oppressive"
            
        dewpoint_info = f"""
            <div style="margin-top: 8px; font-size: 14px;">
                üíß <strong>Dew Point:</strong> <span style="color: {dewpoint_color}; font-weight: bold;">{dewpoint}¬∞F ({dewpoint_desc})</span>
            </div>
        """
    
    # Heat stress indicator
    heat_stress_colors = {
        'Minimal': '#4CAF50',
        'Low': '#8BC34A', 
        'Moderate': '#FF9800',
        'High': '#FF5722',
        'Extreme': '#F44336',
        'Unknown': '#999'
    }
    heat_stress_color = heat_stress_colors.get(heat_stress, '#999')
    
    # Determine AQI color
    aqi_colors = {
        'Good': '#4CAF50',
        'Moderate': '#FF9800',
        'Unhealthy for Sensitive': '#FF5722',
        'Unhealthy': '#F44336',
        'Very Unhealthy': '#9C27B0',
        'Hazardous': '#7B1FA2',
        'Unknown': '#999'
    }
    aqi_color = aqi_colors.get(aqi_category, '#999')
    
    return f"""
        <div style="background: {score_bg}; border: 2px solid {score_color}; border-radius: 12px; padding: 16px; margin: 12px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                <h3 style="margin: 0; font-size: 20px; color: #333; font-weight: bold;">‚è∞ {hour['Hour']}</h3>
                <div style="color: {score_color}; font-weight: bold; font-size: 18px; background: white; padding: 6px 12px; border-radius: 20px; border: 2px solid {score_color};">
                    {stars} ({final_score}/5)
                </div>
            </div>
            <div style="font-size: 15px; font-weight: bold; margin-bottom: 8px;">
                {weather_details}
            </div>
            {dewpoint_info}
            <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; font-size: 13px;">
                <div style="background: {heat_stress_color}20; color: {heat_stress_color}; padding: 4px 8px; border-radius: 6px; font-weight: bold; border: 1px solid {heat_stress_color};">
                    üå°Ô∏è Heat Stress: {heat_stress}
                </div>
                <div style="background: {aqi_color}20; color: {aqi_color}; padding: 4px 8px; border-radius: 6px; font-weight: bold; border: 1px solid {aqi_color};">
                    üå¨Ô∏è Air Quality: {aqi_category}
                </div>
            </div>
            <div style="margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 8px; font-size: 14px; font-style: italic; color: #555;">
                üí° {recommendation}
            </div>
        </div>
    """


def get_formatted_date_display() -> str:
    """Generate a dynamic date display for the current date."""
    from datetime import datetime
    
    now = datetime.now()
    
    # Format: "Mon, Sep 22"
    formatted_date = now.strftime("%a, %b %d")
    
    # Create a styled date display that's more readable
    date_display = f"""
    <div style="
        display: inline-block; 
        background: linear-gradient(135deg, #4CAF50, #2E7D32); 
        color: white; 
        padding: 8px 16px; 
        border-radius: 8px; 
        font-weight: bold; 
        font-size: 16px; 
        text-align: center; 
        margin-right: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    ">
        {formatted_date}
    </div>"""
    
    return date_display

def get_formatted_tomorrow_date_display() -> str:
    """Generate a dynamic date display for tomorrow's date (current + 1 day)."""
    from datetime import datetime, timedelta
    
    tomorrow = datetime.now() + timedelta(days=1)
    
    # Format: "Tue, Sep 23"
    formatted_date = tomorrow.strftime("%a, %b %d")
    
    # Create a styled date display that's more readable
    date_display = f"""
    <div style="
        display: inline-block; 
        background: linear-gradient(135deg, #2196F3, #1565C0); 
        color: white; 
        padding: 8px 16px; 
        border-radius: 8px; 
        font-weight: bold; 
        font-size: 16px; 
        text-align: center; 
        margin-right: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    ">
        {formatted_date}
    </div>"""

    return date_display

def parse_weather_data(forecast_data: str) -> dict:
    """Parse weather forecast data - FIXED to properly handle MCP server JSON output."""
    
    logger.info(f"DEBUG: Received forecast_data type: {type(forecast_data)}, length: {len(forecast_data) if forecast_data else 0}")
    
    if not forecast_data or not forecast_data.strip():
        logger.info("DEBUG: parse_weather_data received empty data")
        return {'today': [], 'tomorrow': []}
    
    # Check if this is JSON data (from MCP server)
    forecast_data_stripped = forecast_data.strip()
    if forecast_data_stripped.startswith('{'):
        logger.info("DEBUG: Using JSON parsing method")
        return parse_json_weather_data_corrected(forecast_data_stripped)
    else:
        # Fallback to pipe-delimited parsing
        logger.warning("DEBUG: Using pipe-delimited fallback - data quality may be reduced")
        return parse_pipe_delimited_weather_data(forecast_data_stripped)


def parse_json_weather_data_corrected(forecast_data: str) -> dict:
    """Parse JSON weather data using the MCP server's pre-processed structure."""
    try:
        import json
        import re
        from datetime import datetime, timezone, timedelta
        
        weather_json = json.loads(forecast_data)
        logger.info(f"DEBUG: Successfully parsed JSON weather data")
        
        # The MCP server returns data in this structure:
        # {"properties": {"periods": [{"day_category": "TODAY-Sep 22, Monday", "parsed_hour": 7, ...}]}}
        periods = weather_json.get('properties', {}).get('periods', [])
        
        if not periods:
            logger.info("DEBUG: No periods found in JSON data")
            return {'today': [], 'tomorrow': []}
        
        logger.info(f"DEBUG: Found {len(periods)} periods in JSON data")
        
        today_data = []
        tomorrow_data = []
        
        # Get current time for day categorization
        now = datetime.now()
        today_date = now.date()
        tomorrow_date = today_date + timedelta(days=1)
        
        for i, period in enumerate(periods):
            try:
                # Use the MCP server's pre-processed data
                day_category = period.get('day_category', '')
                parsed_hour = period.get('parsed_hour', 'N/A')
                
                # Skip if essential data is missing
                if parsed_hour == 'N/A':
                    logger.warning(f"DEBUG: Skipping period {i} - no parsed_hour")
                    continue
                
                # Format hour for display
                hour_num = parsed_hour
                if hour_num == 0:
                    formatted_hour = "12:00 AM"
                elif hour_num < 12:
                    formatted_hour = f"{hour_num}:00 AM"
                elif hour_num == 12:
                    formatted_hour = "12:00 PM"
                else:
                    formatted_hour = f"{hour_num - 12}:00 PM"
                
                # Extract weather data
                temp = period.get('temperature', 'N/A')
                
                # Extract wind speed number
                wind_speed_str = str(period.get('wind_speed', '0 mph'))
                wind_match = re.search(r'(\d+)', wind_speed_str)
                wind = int(wind_match.group(1)) if wind_match else 0
                
                # Get precipitation and humidity (already processed by MCP server)
                precip = period.get('precipitation', 0)
                precip = precip if precip is not None else 0
                
                humidity = period.get('humidity', 'N/A')
                
                # Get forecast description
                forecast = period.get('forecast', 'N/A')
                
                # Get dewpoint
                dewpoint = period.get('dewpoint_fahrenheit', 'N/A')

                # Create weather entry
                weather_entry = {
                    'Hour': formatted_hour,
                    'HourNum': hour_num,
                    'Temp': temp,
                    'Wind': wind,
                    'Precip': precip,
                    'Humidity': humidity,
                    'Forecast': forecast,
                    'dewpoint_fahrenheit': dewpoint
                }
                
                # Use MCP server's day categorization, but also fall back to time-based logic
                if day_category and 'TODAY' in day_category.upper():
                    weather_entry['Day'] = 'today'
                    today_data.append(weather_entry)
                    logger.info(f"DEBUG: Added to TODAY: {hour_num}:00 (category: {day_category})")
                elif day_category and 'TOMORROW' in day_category.upper():
                    weather_entry['Day'] = 'tomorrow'
                    tomorrow_data.append(weather_entry)
                    logger.info(f"DEBUG: Added to TOMORROW: {hour_num}:00 (category: {day_category})")
                else:
                    # Fallback: use raw_start_time to determine day
                    raw_start_time = period.get('raw_start_time', '')
                    if raw_start_time:
                        try:
                            dt = datetime.fromisoformat(raw_start_time.replace('Z', '+00:00'))
                            forecast_date = dt.date()
                            
                            if forecast_date == today_date:
                                weather_entry['Day'] = 'today'
                                today_data.append(weather_entry)
                                logger.info(f"DEBUG: Added to TODAY (fallback): {hour_num}:00")
                            elif forecast_date == tomorrow_date:
                                weather_entry['Day'] = 'tomorrow'
                                tomorrow_data.append(weather_entry)
                                logger.info(f"DEBUG: Added to TOMORROW (fallback): {hour_num}:00")
                            else:
                                logger.info(f"DEBUG: Skipping period beyond tomorrow: {forecast_date}")
                        except Exception as parse_error:
                            logger.warning(f"DEBUG: Could not parse raw_start_time {raw_start_time}: {parse_error}")
                    else:
                        logger.warning(f"DEBUG: No day category or raw_start_time for period {i}")
                        
            except Exception as e:
                logger.warning(f"Error parsing period {i}: {e}")
                continue
        
        # Sort data by hour number
        today_data.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)
        tomorrow_data.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)
        
        logger.info(f"DEBUG: JSON parsing returned {len(today_data)} today entries, {len(tomorrow_data)} tomorrow entries")
        
        # Log sample data for debugging
        if today_data:
            logger.info(f"DEBUG: First today entry: Hour={today_data[0]['Hour']}, Temp={today_data[0]['Temp']}, Wind={today_data[0]['Wind']}")
        if tomorrow_data:
            logger.info(f"DEBUG: First tomorrow entry: Hour={tomorrow_data[0]['Hour']}, Temp={tomorrow_data[0]['Temp']}, Wind={tomorrow_data[0]['Wind']}")
            
        return {'today': today_data, 'tomorrow': tomorrow_data}
        
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON weather data: {e}")
        return {'today': [], 'tomorrow': []}
    except Exception as e:
        logger.error(f"Error parsing JSON weather data: {e}")
        return {'today': [], 'tomorrow': []}

    
def parse_pipe_delimited_weather_data(forecast_data: str) -> dict:
    """Parse pipe-delimited weather data - fallback method only."""
    
    weather_lines = [line.strip() for line in forecast_data.split('\n') if line.strip()]
    
    if not weather_lines:
        logger.info("DEBUG: parse_pipe_delimited found no valid lines")
        return {'today': [], 'tomorrow': []}
    
    # Find data lines (skip headers and separators)
    data_lines = []
    for line in weather_lines:
        if '|' in line and re.search(r'\d+', line) and not line.startswith('+=') and not line.startswith('+--'):
            if not any(header in line.lower() for header in ['num', 'time', 'temp', 'wind', 'forecast', 'precip', 'humidity']):
                data_lines.append(line)
    
    logger.info(f"DEBUG: parse_pipe_delimited found {len(data_lines)} data lines")
    
    today_data = []
    tomorrow_data = []
    
    # FIXED: Sequential assignment instead of time-based logic
    for line_num, line in enumerate(data_lines):
        try:
            if '|' in line:
                parts = [part.strip() for part in line.split('|') if part.strip()]
                if len(parts) >= 8:
                    # Parse all the fields
                    hour_str = parts[1]  # Time column
                    temp_str = parts[2]   # Temperature column
                    wind_str = parts[3]   # Wind speed column
                    forecast_str = parts[5] if len(parts) > 5 else "N/A"  # Forecast column
                    precip_str = parts[6] if len(parts) > 6 else "N/A"    # Precipitation column
                    humidity_str = parts[7] if len(parts) > 7 else "N/A"  # Humidity column
                    
                    # Extract hour number
                    hour_match = re.search(r'(\d{1,2})', hour_str)
                    if hour_match:
                        hour_num = int(hour_match.group(1))
                        # Format hour with AM/PM
                        if hour_num == 0:
                            formatted_hour = "12:00 AM"
                        elif hour_num < 12:
                            formatted_hour = f"{hour_num}:00 AM"
                        elif hour_num == 12:
                            formatted_hour = "12:00 PM"
                        else:
                            formatted_hour = f"{hour_num - 12}:00 PM"
                    else:
                        hour_num = "N/A"
                        formatted_hour = "N/A"
                        logger.warning(f"Could not parse hour from: {hour_str}")
                    
                    # Extract temperature
                    temp_numbers = re.findall(r'\d+', temp_str)
                    if temp_numbers:
                        temp = int(temp_numbers[0])
                    else:
                        temp = "N/A"
                        logger.warning(f"Could not parse temperature from: {temp_str}")
                    
                    # Extract wind
                    wind_numbers = re.findall(r'\d+', wind_str)
                    if wind_numbers:
                        wind = int(wind_numbers[0])
                    else:
                        wind = "N/A"
                        logger.warning(f"Could not parse wind from: {wind_str}")
                    
                    # Extract precipitation
                    precip_numbers = re.findall(r'\d+', precip_str)
                    if precip_numbers:
                        precip = int(precip_numbers[0])
                    else:
                        precip = "N/A"
                        logger.warning(f"Could not parse precipitation from: {precip_str}")
                    
                    # Extract humidity
                    humidity_numbers = re.findall(r'\d+', humidity_str)
                    if humidity_numbers:
                        humidity = int(humidity_numbers[0])
                    else:
                        humidity = "N/A"
                        logger.warning(f"Could not parse humidity from: {humidity_str}")
                    
                    forecast = forecast_str.strip() if forecast_str.strip() else "N/A"
                    
                    # Create weather entry
                    weather_entry = {
                        'Hour': formatted_hour,
                        'HourNum': hour_num,
                        'Temp': temp,
                        'Wind': wind,
                        'Precip': precip,
                        'Humidity': humidity,
                        'Forecast': forecast
                    }
                    
                    # FIXED: Sequential assignment (first 24 hours = today, next 24 = tomorrow)
                    if line_num < 24:
                        weather_entry['Day'] = 'today'
                        today_data.append(weather_entry)
                    else:
                        weather_entry['Day'] = 'tomorrow'
                        tomorrow_data.append(weather_entry)
                        
        except (ValueError, IndexError) as e:
            logger.warning(f"Error parsing pipe-delimited line {line_num}: {line} - {e}")
            continue
    
    # Sort data by hour number for consistent ordering
    today_data.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)
    tomorrow_data.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)
    
    logger.info(f"DEBUG: Pipe-delimited parsing returned {len(today_data)} today entries, {len(tomorrow_data)} tomorrow entries")
    return {'today': today_data, 'tomorrow': tomorrow_data}

def calculate_rwi_score(temperature, humidity, wind_speed, precipitation, forecast, dewpoint_fahrenheit):
    """
    Calculate Running Weather Index using the provided scientific approach
    Returns RWI score (1-5), heat index, and component scores
    """
    from enhanced_rwi import calculate_rwi  # Import the RWI function
    
    try:
        result = calculate_rwi(
            temperature=temperature,
            humidity=humidity, 
            wind_speed=wind_speed,
            precipitation=precipitation,
            forecast=forecast,
            dewpoint_fahrenheit=dewpoint_fahrenheit
        )
        return result
    except Exception as e:
        logger.warning(f"RWI calculation failed: {e}, falling back to basic calculation")
        # Fallback basic calculation
        return {
            'rwi_score': 3.0,
            'rating': 3,
            'heat_index': temperature if temperature != "N/A" else 75.0,
            'components': {
                'thermal_comfort': 3.0,
                'solar_conditions': 3.0,
                'wind': 3.0,
                'precipitation': 3.0,
                'dewpoint_comfort': 3.0
            }
        }

def filter_weather_by_time_range(weather_data: list, start_hour: int, end_hour: int, spans_days: bool = False) -> list:
    """Filter weather data by hour range, handling cross-day scenarios."""
    filtered_data = []
    
    logger.info(f"DEBUG: Filtering weather data - start_hour={start_hour}, end_hour={end_hour}, spans_days={spans_days}")
    logger.info(f"DEBUG: Input data contains {len(weather_data)} hours")
    
    for hour_data in weather_data:
        hour_num = hour_data['HourNum']
        day = hour_data.get('Day', 'today')
        
        # Skip if hour_num is N/A
        if hour_num == "N/A":
            logger.info(f"DEBUG: Skipping hour with N/A HourNum from {day}")
            continue
        
        logger.info(f"DEBUG: Processing hour {hour_num} ({hour_data['Hour']}) from {day}")
        
        should_include = False
        
        if spans_days:
            # Handle cross-day scenarios (e.g., 4PM today to 11AM tomorrow)
            if day == 'today':
                # Keep hours >= start_hour for today
                if hour_num >= start_hour:
                    should_include = True
                    logger.info(f"DEBUG: KEPT today hour {hour_num} (>= {start_hour}) - CROSS-DAY LOGIC")
                else:
                    logger.info(f"DEBUG: FILTERED OUT today hour {hour_num} (< {start_hour}) - CROSS-DAY LOGIC")
            elif day == 'tomorrow':
                # Keep hours <= end_hour for tomorrow
                if hour_num <= end_hour:
                    should_include = True
                    logger.info(f"DEBUG: KEPT tomorrow hour {hour_num} (<= {end_hour}) - CROSS-DAY LOGIC")
                else:
                    logger.info(f"DEBUG: FILTERED OUT tomorrow hour {hour_num} (> {end_hour}) - CROSS-DAY LOGIC")
        else:
            # Single day scenario
            logger.info(f"DEBUG: Using SINGLE-DAY logic for {day}")
            if start_hour <= end_hour:
                # Normal case: 8 AM to 11 AM (same day)
                if start_hour <= hour_num <= end_hour:
                    should_include = True
                    logger.info(f"DEBUG: KEPT {day} hour {hour_num} (within range {start_hour}-{end_hour}) - SINGLE-DAY LOGIC")
                else:
                    logger.info(f"DEBUG: FILTERED OUT {day} hour {hour_num} (outside range {start_hour}-{end_hour}) - SINGLE-DAY LOGIC")
            else:
                # Cross-midnight case within same day: 10 PM to 6 AM
                if hour_num >= start_hour or hour_num <= end_hour:
                    should_include = True
                    logger.info(f"DEBUG: KEPT {day} hour {hour_num} (cross-midnight range) - SINGLE-DAY LOGIC")
                else:
                    logger.info(f"DEBUG: FILTERED OUT {day} hour {hour_num} (outside cross-midnight range) - SINGLE-DAY LOGIC")
        
        if should_include:
            filtered_data.append(hour_data)
    
    logger.info(f"DEBUG: Filtering complete - kept {len(filtered_data)} hours out of {len(weather_data)}")
    return filtered_data

def extract_dual_query_parameters(city: str, today_start: str, today_end: str, tomorrow_start: str, tomorrow_end: str) -> dict:
    """Extract parameters for dual time window queries."""
    
    def time_to_hour(time_str):
        """Convert HH:MM to hour number"""
        return int(time_str.split(':')[0])
    
    result = {
        'city': city,
        'today_start_hour': time_to_hour(today_start),
        'today_end_hour': time_to_hour(today_end),
        'tomorrow_start_hour': time_to_hour(tomorrow_start),
        'tomorrow_end_hour': time_to_hour(tomorrow_end),
        'today_start': today_start,
        'today_end': today_end,
        'tomorrow_start': tomorrow_start,
        'tomorrow_end': tomorrow_end
    }
    
    logger.info(f"DEBUG: Dual window parameters - {result}")
    return result

def score_hour_with_scientific_approach(hour_data, aqi_value=None):
    """
    RWI-Enhanced scoring function with temperature safety overrides.
    
    Key features:
    1. Uses Running Weather Index for base scoring
    2. Temperature safety overrides: >=85¬∞F = 2/5, >=90¬∞F = 1/5
    3. Considers solar/cloud conditions from forecast
    4. Aligns recommendations with actual weather parameters
    """
    
    # Extract and validate data
    temp = hour_data.get('temperature', hour_data.get('Temp', 'N/A'))
    wind = hour_data.get('wind_speed', hour_data.get('Wind', 'N/A'))
    humidity = hour_data.get('humidity', hour_data.get('Humidity', 'N/A'))
    precip = hour_data.get('precipitation', hour_data.get('Precip', 'N/A'))
    dewpoint = hour_data.get('dewpoint_fahrenheit', 'N/A')
    forecast = str(hour_data.get('forecast', hour_data.get('Forecast', 'N/A'))).lower()
    
    # Parse wind speed if string format
    if isinstance(wind, str) and wind != "N/A":
        import re
        wind_match = re.search(r'(\d+)', wind)
        wind = int(wind_match.group(1)) if wind_match else 0

    # Set defaults for missing data
    if temp == "N/A":
        temp = 70  # Neutral default
    if humidity == "N/A":
        humidity = 50  # Moderate default
    if wind == "N/A":
        wind = 5   # Light breeze default
    if precip == "N/A":
        precip = 0  # No precipitation default
    if dewpoint == "N/A":
        dewpoint = temp - 15  # Estimate dewpoint
    
    # Calculate RWI using the enhanced algorithm
    try:
        rwi_result = calculate_rwi_score(
            temperature=temp,
            humidity=humidity,
            wind_speed=wind,
            precipitation=precip,
            forecast=forecast,
            dewpoint_fahrenheit=dewpoint
        )
        
        base_rwi_rating = rwi_result['rating']
        heat_index = rwi_result['heat_index']
        rwi_components = rwi_result['components']
        
    except Exception as e:
        logger.warning(f"RWI calculation failed: {e}")
        # Fallback to basic rating
        if temp >= 85:
            base_rwi_rating = 2
        elif temp >= 90:
            base_rwi_rating = 1
        else:
            base_rwi_rating = 3
        heat_index = temp
        rwi_components = {}

    # SAFETY OVERRIDES - Temperature thresholds
    if temp >= 90:
        final_score = 1  # Dangerous heat - override RWI
        temp_risk = DANGEROUS
        temp_msg = f"Dangerous heat ({temp}¬∞F). Heat stroke risk is high. Avoid outdoor running."
    elif temp >= 85:
        final_score = 2  # High risk heat - override RWI  
        temp_risk = HIGH_RISK
        temp_msg = f"High heat stress ({temp}¬∞F). Easy pace only, frequent hydration breaks required."
    else:
        # Use RWI rating for temperatures < 85¬∞F
        final_score = base_rwi_rating
        if temp >= 80:
            temp_risk = HIGH_RISK
            temp_msg = f"High heat stress developing ({temp}¬∞F). Monitor closely and hydrate frequently."
        elif temp >= 75:
            temp_risk = CAUTION
            temp_msg = f"Heat stress present ({temp}¬∞F). Reduce intensity for longer runs."
        elif temp >= 50:
            temp_risk = OPTIMAL
            temp_msg = f"Good temperature for running ({temp}¬∞F)."
        elif temp >= 32:
            temp_risk = GOOD
            temp_msg = f"Cool conditions ({temp}¬∞F). Extend warm-up time."
        else:
            temp_risk = CAUTION
            temp_msg = f"Cold conditions ({temp}¬∞F). Layer appropriately and protect extremities."

    # Enhanced humidity/dewpoint assessment
    if dewpoint <= 50:
        humidity_risk = OPTIMAL
        humidity_msg = "Excellent conditions for heat dissipation."
    elif dewpoint <= 60:
        humidity_risk = GOOD  
        humidity_msg = "Comfortable humidity levels."
    elif dewpoint <= 65:
        humidity_risk = CAUTION
        humidity_msg = f"Humid conditions (dewpoint {dewpoint}¬∞F). Extra hydration advised."
    elif dewpoint <= 70:
        humidity_risk = HIGH_RISK
        humidity_msg = f"Oppressive humidity (dewpoint {dewpoint}¬∞F). Significant heat stress risk."
    else:
        humidity_risk = DANGEROUS
        humidity_msg = f"Dangerous humidity (dewpoint {dewpoint}¬∞F). Heat stroke risk is elevated."

    # Solar/cloud cover assessment (enhanced from forecast)
    solar_risk = OPTIMAL
    solar_msg = ""
    if any(word in forecast for word in ['sunny', 'clear', 'fair']):
        if heat_index > 75:
            solar_risk = CAUTION
            solar_msg = f"Direct sun adds effective temperature. Seek shade when possible."
        else:
            solar_msg = "Sunny conditions are pleasant for cooler temperatures."
    elif any(word in forecast for word in ['partly cloudy', 'partly sunny']):
        solar_msg = "Mixed sun and clouds provide variable conditions."
    elif any(word in forecast for word in ['cloudy', 'overcast']):
        if heat_index > 75:
            solar_msg = "Cloud cover provides beneficial relief from direct sun."
        else:
            solar_msg = "Overcast conditions are neutral for running."

    # Wind assessment
    if wind <= 5:
        wind_risk = GOOD
        wind_msg = f"Light wind ({wind} mph) provides minimal cooling."
    elif wind <= 15:
        wind_risk = OPTIMAL
        wind_msg = f"Moderate wind ({wind} mph) provides excellent cooling effect."
    elif wind <= 25:
        wind_risk = CAUTION  
        wind_msg = f"Strong wind ({wind} mph). Focus on effort rather than pace."
    else:
        wind_risk = HIGH_RISK
        wind_msg = f"Very strong wind ({wind} mph). Safety concern for balance and debris."

    # Precipitation assessment
    if precip == 0:
        precip_risk = OPTIMAL
        precip_msg = "No precipitation."
    elif precip <= 20:
        precip_risk = GOOD
        precip_msg = f"Light precipitation possible ({precip}%)."
    elif precip <= 50:
        precip_risk = CAUTION
        precip_msg = f"Moderate rain likely ({precip}%). Reduced traction."
    else:
        precip_risk = HIGH_RISK
        precip_msg = f"Heavy precipitation likely ({precip}%). Slip hazard."

    # Air quality assessment  
    if aqi_value is None or aqi_value == "N/A":
        aqi_risk = OPTIMAL
        aqi_msg = ""
    elif aqi_value <= 100:
        aqi_risk = OPTIMAL
        aqi_msg = f"Air quality is acceptable (AQI {aqi_value})."
    elif aqi_value <= 150:
        aqi_risk = CAUTION
        aqi_msg = f"Air quality unhealthy for sensitive groups (AQI {aqi_value})."
    else:
        aqi_risk = HIGH_RISK
        aqi_msg = f"Poor air quality (AQI {aqi_value}). Limit outdoor exercise."

    # Overall risk is maximum of all factors
    overall_risk_numeric = max(temp_risk, humidity_risk, solar_risk, wind_risk, precip_risk, aqi_risk)
    risk_level_names = {0: "OPTIMAL", 1: "GOOD", 2: "CAUTION", 3: "HIGH_RISK", 4: "DANGEROUS"}
    overall_risk_name = risk_level_names.get(overall_risk_numeric, "UNKNOWN")

    # Generate comprehensive recommendation
    recommendation = _generate_rwi_recommendation(
        temp, dewpoint, wind, precip, forecast, aqi_value, 
        final_score, overall_risk_numeric
    )

    return {
        **hour_data,
        'score_100': final_score * 20,  # Convert 1-5 to 0-100 scale  
        'final_score': final_score,
        'overall_risk': overall_risk_name,
        'overall_risk_numeric': overall_risk_numeric,
        'heat_stress_level': _calculate_heat_stress_level(temp, dewpoint),
        'aqi_category': _get_aqi_category(aqi_value),
        'running_recommendation': recommendation,
        'rwi_components': rwi_components if 'rwi_components' in locals() else {},
        'heat_index': heat_index if 'heat_index' in locals() else temp
    }

def score_hour_with_rwi(hour_data, aqi_value=None):
    """
    RWI-based scoring (continuous, no artificial caps).
    Stars reflect overall comfort + performance suitability.
    Guidance flags highlight specific risks.
    """
    score = 100
    
    # --- existing temperature, dew point, wind, precip, AQI, forecast scoring logic ---
    # (unchanged, same as your function above)
    # ...
    
    # Ensure score remains within bounds
    score = max(0, min(100, score))

    # Get individual risk assessments (only for guidance, not star override)
    heat_risk, heat_msg = _get_heat_stress_guidance_enhanced(
        hour_data.get('temperature', hour_data.get('Temp', 'N/A')),
        hour_data.get('dewpoint_fahrenheit', 'N/A')
    )
    cold_risk, cold_msg = _get_cold_stress_guidance_enhanced(
        hour_data.get('temperature', hour_data.get('Temp', 'N/A')),
        hour_data.get('wind_speed', hour_data.get('Wind', 'N/A'))
    )
    wind_risk, wind_msg = _get_wind_guidance_enhanced(
        hour_data.get('wind_speed', hour_data.get('Wind', 'N/A'))
    )
    precip_risk, precip_msg = _get_precipitation_guidance_enhanced(
        hour_data.get('precipitation', hour_data.get('Precip', 'N/A')),
        str(hour_data.get('forecast', hour_data.get('Forecast', ''))).lower()
    )
    aqi_risk, aqi_msg = _get_aqi_guidance_enhanced(aqi_value)

    # --- RWI star assignment (no caps, just score ranges) ---
    if score >= 85:
        final_score = 5
    elif score >= 65:
        final_score = 4
    elif score >= 45:
        final_score = 3
    elif score >= 25:
        final_score = 2
    else:
        final_score = 1

    # Overall risk is max of the factors (for guidance only)
    overall_risk_numeric = max(heat_risk, cold_risk, wind_risk, precip_risk, aqi_risk)
    risk_level_names = {0: "OPTIMAL", 1: "GOOD", 2: "CAUTION", 3: "HIGH_RISK", 4: "DANGEROUS"}
    overall_risk_name = risk_level_names.get(overall_risk_numeric, "UNKNOWN")

    return {
        **hour_data,
        'score_100': score,
        'final_score': final_score,
        'overall_risk': overall_risk_name,
        'overall_risk_numeric': overall_risk_numeric,
        'heat_stress_level': _calculate_heat_stress_level(
            hour_data.get('temperature', hour_data.get('Temp', 'N/A')),
            hour_data.get('dewpoint_fahrenheit', 'N/A')
        ),
        'aqi_category': _get_aqi_category(aqi_value),
        'running_recommendation': _get_running_recommendation_enhanced(hour_data, aqi_value, score)
    }

def _generate_rwi_recommendation(temp, dewpoint, wind, precip, forecast, aqi_value, final_score, overall_risk):
    """
    Generate RWI-based running recommendations aligned with actual weather parameters.
    """
    recommendations = []
    
    # Temperature-specific guidance
    if temp >= 90:
        recommendations.append("üå°Ô∏è DANGEROUS HEAT: Avoid outdoor running. Heat stroke risk is very high.")
        recommendations.append("üè† Move indoors or postpone until temperatures drop below 85¬∞F.")
    elif temp >= 85:
        recommendations.append("üî• HIGH HEAT STRESS: Easy pace only with frequent breaks.")
        recommendations.append("üíß Hydrate every 10-15 minutes. Pre-cool with cold fluids.")
        recommendations.append("üå≥ Seek shaded routes and avoid direct sun exposure.")
    elif temp >= 80:
        recommendations.append("‚ö†Ô∏è HEAT STRESS DEVELOPING: Reduce intensity for runs longer than 30 minutes.")
        recommendations.append("üíß Increase hydration frequency to every 15-20 minutes.")
    elif temp >= 75:
        recommendations.append("üå°Ô∏è WARM CONDITIONS: Monitor effort level and hydration needs.")
    elif temp >= 50:
        recommendations.append("üëç GOOD TEMPERATURE: Comfortable for all training intensities.")
    elif temp >= 32:
        recommendations.append("üß• COOL CONDITIONS: Allow extra time for warm-up.")
    else:
        recommendations.append("ü•∂ COLD CONDITIONS: Layer appropriately and protect extremities.")

    # Dewpoint/humidity guidance
    if dewpoint > 70:
        recommendations.append(f"üí¶ OPPRESSIVE HUMIDITY: Dewpoint {dewpoint}¬∞F severely impairs cooling.")
    elif dewpoint > 65:
        recommendations.append(f"üíß HIGH HUMIDITY: Dewpoint {dewpoint}¬∞F increases heat stress significantly.")
    elif dewpoint > 60:
        recommendations.append(f"üíß NOTICEABLE HUMIDITY: Dewpoint {dewpoint}¬∞F may affect comfort.")

    # Solar/cloud guidance
    if 'sunny' in forecast or 'clear' in forecast:
        if temp > 75:
            recommendations.append("‚òÄÔ∏è DIRECT SUN: Adds 10-15¬∞F to effective temperature. Seek shade.")
        else:
            recommendations.append("‚òÄÔ∏è SUNNY CONDITIONS: Pleasant for cooler temperatures.")
    elif 'cloudy' in forecast or 'overcast' in forecast:
        if temp > 75:
            recommendations.append("‚òÅÔ∏è CLOUD COVER: Provides beneficial relief from direct sun.")

    # Wind guidance
    if wind > 20:
        recommendations.append(f"üí® STRONG WIND: {wind} mph affects pacing. Run by effort, not speed.")
    elif wind > 15:
        recommendations.append(f"üí® MODERATE WIND: {wind} mph provides cooling but may affect pace.")
    elif 5 <= wind <= 15:
        recommendations.append(f"üå¨Ô∏è BENEFICIAL WIND: {wind} mph provides excellent cooling.")

    # Precipitation guidance  
    if precip > 50:
        recommendations.append(f"üåßÔ∏è HEAVY RAIN LIKELY: {precip}% chance. Significant slip hazard.")
    elif precip > 20:
        recommendations.append(f"üå¶Ô∏è RAIN POSSIBLE: {precip}% chance. Adjust pace for wet conditions.")

    # Air quality guidance
    if aqi_value and aqi_value != "N/A":
        if aqi_value > 150:
            recommendations.append(f"üö´ POOR AIR QUALITY: AQI {aqi_value}. Consider indoor alternatives.")
        elif aqi_value > 100:
            recommendations.append(f"‚ö†Ô∏è MODERATE AIR QUALITY: AQI {aqi_value}. Sensitive individuals use caution.")

    # Overall assessment based on final score
    if final_score == 5:
        header = "‚úÖ EXCELLENT CONDITIONS"
        recommendations.insert(0, "Perfect conditions for any training intensity!")
    elif final_score == 4:
        header = "üëç VERY GOOD CONDITIONS" 
        recommendations.insert(0, "Great conditions with minor considerations.")
    elif final_score == 3:
        header = "‚ö†Ô∏è FAIR CONDITIONS"
        recommendations.insert(0, "Moderate conditions requiring attention to safety factors.")
    elif final_score == 2:
        header = "‚ö†Ô∏è CHALLENGING CONDITIONS"
        recommendations.insert(0, "Significant environmental stress. Easy pace only.")
    else:
        header = "üõë POOR CONDITIONS"
        recommendations.insert(0, "High risk conditions. Consider postponing outdoor running.")

    # Format final recommendation
    rec_list = "</li><li>".join(recommendations)
    return f"{header}<ul><li>{rec_list}</li></ul>"


def _calculate_heat_stress_level(temp, dewpoint):
    """Calculate heat stress level based on temperature and dew point."""
    if temp == "N/A" or dewpoint == "N/A":
        return "Unknown"
    
    if dewpoint <= 55 and temp <= 70:
        return "Minimal"
    elif dewpoint <= 60 and temp <= 75:
        return "Low"
    elif dewpoint <= 65 and temp <= 80:
        return "Moderate"
    elif dewpoint <= 70 and temp <= 85:
        return "High"
    else:
        return "Extreme"

def _get_aqi_category(aqi_value):
    """Get AQI health category."""
    if aqi_value is None or aqi_value == "N/A":
        return "Unknown"
    elif aqi_value <= 50:
        return "Good"
    elif aqi_value <= 100:
        return "Moderate"
    elif aqi_value <= 150:
        return "Unhealthy for Sensitive"
    elif aqi_value <= 200:
        return "Unhealthy"
    elif aqi_value <= 300:
        return "Very Unhealthy"
    else:
        return "Hazardous"

# --- NEW RECOMMENDATION ENGINE ---

def _get_heat_stress_guidance_enhanced(temp, dewpoint):
    """
    Enhanced heat stress classification (conservative).
    Aligned with exercise physiology and safety guidance.
    """
    if temp == "N/A" or dewpoint == "N/A":
        return (CAUTION, "Heat data unavailable. Monitor exertion closely and hydrate often.")

    if temp <= 60:
        if dewpoint <= 55:
            return (OPTIMAL, "Cool and comfortable conditions.")
        elif dewpoint <= 60:
            return (GOOD, "Cool air but humidity noticeable. Stay hydrated.")
        else:
            return (CAUTION, "High humidity despite cool air. Extra hydration advised.")

    elif 60 < temp <= 70:
        if dewpoint <= 50:
            return (OPTIMAL, "Very comfortable conditions.")
        elif dewpoint <= 55:
            return (GOOD, "Good for running. Stay hydrated on longer efforts.")
        elif dewpoint <= 60:
            return (CAUTION, "Humidity adds stress. Reduce pace for longer runs.")
        else:
            return (HIGH_RISK, "Warm and humid. Easy pace only.")

    elif 70 < temp <= 75:
        if dewpoint <= 50:
            return (GOOD, "Warm but manageable. Pre-hydrate and monitor effort.")
        elif dewpoint <= 60:
            return (CAUTION, "Heat stress developing. Plan hydration stops.")
        elif dewpoint <= 70:
            return (CAUTION, "Moderate stress. Limit long/intense runs.")
        else:
            return (HIGH_RISK, "Significant stress. Easy effort or move indoors.")

    elif 75 < temp <= 80:
        if dewpoint <= 55:
            return (CAUTION, "Hot conditions. Reduce duration and hydrate often.")
        elif dewpoint <= 65:
            return (HIGH_RISK, "High stress. Short easy runs only with cooling strategies.")
        else:
            return (DANGEROUS, "Very risky. Outdoor running not recommended.")

    elif 80 < temp <= 85:
        if dewpoint <= 55:
            return (HIGH_RISK, "High heat stress. Short easy runs only.")
        else:
            return (DANGEROUS, "Dangerous combination. Avoid outdoor runs.")

    elif 85 < temp <= 90:
        if dewpoint <= 55:
            return (HIGH_RISK, "Extreme heat. If running, keep very short with cooling.")
        else:
            return (DANGEROUS, "Life-threatening stress. Avoid outdoor activity.")

    else:  # >90¬∞F
        return (DANGEROUS, "Life-threatening conditions. Avoid all outdoor running.")

def _get_cold_stress_guidance_enhanced(temp, wind):
    """
    Enhanced cold stress classification.
    Considers wind chill and frostbite risk.
    """
    if temp == "N/A":
        return (CAUTION, "Temperature unknown. Dress in layers and monitor for cold stress.")

    # Approximate wind chill
    wind_chill = temp
    if wind != "N/A" and wind > 3:
        wind_chill = temp - (wind * 0.7)

    if temp >= 45:
        return (OPTIMAL, "Comfortable cool weather.")
    
    elif temp >= 32:
        if wind_chill >= 25:
            return (GOOD, "Cool conditions. Warm-up important.")
        elif wind_chill >= 15:
            return (CAUTION, "Cold stress possible. Cover extremities, extend warm-up.")
        else:
            return (CAUTION, "Wind chill adds stress. Layer appropriately.")

    elif temp >= 20:
        if wind_chill >= 10:
            return (CAUTION, "Freezing conditions. Protect hands and face.")
        elif wind_chill >= 0:
            return (HIGH_RISK, "Frostbite risk after ~30 min. Limit exposure.")
        else:
            return (HIGH_RISK, "Dangerous wind chill. Frostbite in ~15 min possible.")

    else:  # <20¬∞F
        if wind_chill >= -5:
            return (HIGH_RISK, "Extreme cold. Frostbite risk high. Short runs only.")
        else:
            return (DANGEROUS, "Life-threatening cold. Frostbite in 5-10 min possible.")


def _get_wind_guidance_enhanced(wind):
    """Enhanced wind assessment based on aerodynamics and safety research."""
    if wind == "N/A":
        return (OPTIMAL, "")
    
    if wind <= 5:
        return (OPTIMAL, "")
    elif wind <= 10:
        return (GOOD, "Light breeze provides beneficial cooling effect.")
    elif wind <= 15:
        return (GOOD, "Moderate wind. Focus on effort rather than pace due to variable resistance.")
    elif wind <= 20:
        return (CAUTION, "Strong wind will significantly impact pacing. Run by perceived effort.")
    elif wind <= 30:
        return (HIGH_RISK, "Very strong wind creates safety hazards. Watch for debris, maintain balance.")
    else:
        return (DANGEROUS, "Dangerous wind speeds. Risk of being knocked off balance or struck by debris.")

def _get_precipitation_guidance_enhanced(precip, forecast):
    """Enhanced precipitation assessment based on safety and biomechanics research."""
    if precip == "N/A":
        return (OPTIMAL, "")
    
    # Check for severe weather first
    if any(term in forecast for term in ['thunderstorm', 'thunder', 'lightning']):
        return (DANGEROUS, "Lightning danger present. Outdoor activity extremely unsafe.")
    
    if any(term in forecast for term in ['freezing rain', 'ice storm', 'sleet']):
        return (DANGEROUS, "Icy conditions create extreme slip hazard. Postpone outdoor running.")
    
    if precip == 0:
        return (OPTIMAL, "")
    elif precip <= 15:
        return (GOOD, "Light precipitation. Minimal impact with appropriate gear.")
    elif precip <= 30:
        return (CAUTION, "Moderate rain. Reduced traction and visibility. Shorten stride, avoid rapid direction changes.")
    elif precip <= 50:
        return (CAUTION, "Heavy rain likely. Significant visibility reduction and slip risk. Consider postponing.")
    else:
        return (HIGH_RISK, "Very heavy precipitation. Poor visibility and high slip risk make outdoor running hazardous.")


def _get_aqi_guidance_enhanced(aqi_value):
    """Enhanced air quality assessment based on EPA guidelines and exercise physiology."""
    if aqi_value == "N/A" or aqi_value is None:
        return (OPTIMAL, "Air quality data unavailable.")
    
    if aqi_value <= 50:
        return (OPTIMAL, "")
    elif aqi_value <= 100:
        return (GOOD, "Air quality is moderate. Sensitive individuals may experience minor symptoms.")
    elif aqi_value <= 150:
        return (CAUTION, "Air quality unhealthy for sensitive groups. Those with asthma or heart conditions should reduce outdoor exercise intensity.")
    elif aqi_value <= 200:
        return (HIGH_RISK, "Air quality is unhealthy. Everyone may experience symptoms. Limit outdoor exercise duration and intensity.")
    elif aqi_value <= 300:
        return (HIGH_RISK, "Very unhealthy air quality. Serious health effects likely with prolonged outdoor activity.")
    else:
        return (DANGEROUS, "Hazardous air quality. Emergency conditions - avoid all outdoor physical activity.")


def _get_running_recommendation_enhanced(hour_data, aqi_value, composite_score):
    """
    Provide evidence-based running recommendations using a multi-factor risk assessment approach.
    Based on ACSM guidelines, IAAF heat stress protocols, and sports medicine research.
    """
    temp = hour_data.get('Temp', 'N/A')
    dewpoint = hour_data.get('dewpoint_fahrenheit', 'N/A')
    wind = hour_data.get('Wind', 'N/A')
    precip = hour_data.get('Precip', 'N/A')
    forecast = str(hour_data.get('Forecast', '')).lower()
    
    # Get individual risk assessments
    heat_risk, heat_msg = _get_heat_stress_guidance_enhanced(temp, dewpoint)
    cold_risk, cold_msg = _get_cold_stress_guidance_enhanced(temp, wind)
    wind_risk, wind_msg = _get_wind_guidance_enhanced(wind)
    precip_risk, precip_msg = _get_precipitation_guidance_enhanced(precip, forecast)
    aqi_risk, aqi_msg = _get_aqi_guidance_enhanced(aqi_value)
    
    # Determine overall risk level (maximum of all factors)
    overall_risk = max(heat_risk, cold_risk, wind_risk, precip_risk, aqi_risk)
    
    # Collect all relevant guidance messages
    guidance_messages = []
    for msg in [heat_msg, cold_msg, wind_msg, precip_msg, aqi_msg]:
        if msg and msg.strip():
            guidance_messages.append(msg)
    
    # Generate risk-appropriate header and recommendations
    if overall_risk == OPTIMAL:
        header = "‚úÖ Optimal Conditions"
        if composite_score >= 85:
            recommendations = ["Perfect conditions for any training intensity.", 
                             "Ideal for tempo runs, intervals, or long runs.",
                             "Maintain normal hydration practices."]
        else:
            recommendations = ["Excellent conditions for running.",
                             "All training intensities appropriate."]
    
    elif overall_risk == GOOD:
        header = "üëç Very Good Conditions"
        recommendations = ["Minor environmental factors to consider.",
                         "Suitable for all training types with minimal adjustments.",
                         "Stay aware of changing conditions."]
    
    elif overall_risk == CAUTION:
        header = "‚ö†Ô∏è Caution Advised"
        if heat_risk >= CAUTION:
            recommendations = ["Moderate heat stress risk present.",
                             "Reduce intensity for runs longer than 45 minutes.",
                             "Increase hydration frequency (every 15-20 minutes).",
                             "Consider running in shaded areas when possible."]
        else:
            recommendations = ["Environmental factors require attention.",
                             "Adjust pace and hydration based on conditions.",
                             "Monitor your body's response closely."]
    
    elif overall_risk == HIGH_RISK:
        header = "‚ùó High Risk - Adjust Your Run"
        recommendations = ["Significant environmental stress present.",
                         "Easy-paced runs only (conversational pace).",
                         "Reduce duration by 25-50% from normal.",
                         "Take walk breaks every 10-15 minutes if needed.",
                         "Hydrate before, during, and after running."]
        
        if heat_risk >= HIGH_RISK:
            recommendations.extend(["Pre-cool with cold fluids 30 minutes before running.",
                                  "Seek shade or air conditioning if feeling overheated.",
                                  "Stop immediately if experiencing dizziness, nausea, or confusion."])
        
        if aqi_risk >= HIGH_RISK:
            recommendations.extend(["Consider wearing an N95 mask during exercise.",
                                  "Avoid busy roads and traffic-heavy areas.",
                                  "Stop if experiencing unusual breathing difficulty."])
    
    else:  # DANGEROUS
        header = "üõë Dangerous Conditions - Avoid Outdoor Running"
        recommendations = ["Current conditions pose serious health risks.",
                         "Postpone outdoor running until conditions improve.",
                         "Consider indoor alternatives (treadmill, indoor track).",
                         "If you must be outdoors, limit exposure to essential activities only."]
    
    # Add specific safety alerts
    safety_alerts = []
    if any(term in forecast for term in ['thunderstorm', 'thunder', 'lightning']):
        safety_alerts.append("‚ö° Lightning Risk: Seek indoor shelter immediately if thunder is heard.")
    
    if temp != "N/A" and temp >= 90 and dewpoint != "N/A" and dewpoint >= 70:
        safety_alerts.append("üå°Ô∏è Heat Emergency Risk: Symptoms include confusion, hot dry skin, rapid pulse.")
    
    if temp != "N/A" and temp <= 20 and wind != "N/A" and wind >= 15:
        safety_alerts.append("ü•∂ Frostbite Risk: Cover all exposed skin; watch for numbness or white/grayish skin.")
    
    if aqi_value != "N/A" and aqi_value is not None and aqi_value >= 200:
        safety_alerts.append("üò∑ Health Emergency: Air quality at dangerous levels affecting everyone.")
    
    # Format the final recommendation
    formatted_recommendations = []
    if recommendations:
        formatted_recommendations.extend([f"<li>{rec}</li>" for rec in recommendations])
    
    if guidance_messages:
        formatted_recommendations.extend([f"<li><em>{msg}</em></li>" for msg in guidance_messages])
    
    if safety_alerts:
        formatted_recommendations.extend([f"<li><strong>{alert}</strong></li>" for alert in safety_alerts])
    
    # Always include general safety reminder
    formatted_recommendations.append("<li><em>Listen to your body and adjust as needed. When in doubt, choose safety first.</em></li>")
    
    if formatted_recommendations:
        recommendation_list = "".join(formatted_recommendations)
        return f"{header}<ul>{recommendation_list}</ul>"
    else:
        return header

def format_value_with_na(value, unit="", na_display="N/A"):
    """Format a value that might be 'N/A' for display."""
    if value == "N/A":
        return f"<span style='color: #999; font-style: italic;'>{na_display}</span>"
    else:
        return f"<span style='font-weight: bold;'>{value}{unit}</span>"

def format_weather_line_with_na(hour):
    """Format a weather line handling N/A values properly - FIXED VERSION."""
    temp_display = format_value_with_na(hour['Temp'], "¬∞F")
    wind_display = format_value_with_na(hour['Wind'], "mph")
    precip_display = format_value_with_na(hour['Precip'], "%")
    humidity_display = format_value_with_na(hour['Humidity'], "%")
    
    # Color coding for temperature
    if hour['Temp'] != "N/A":
        if hour['Temp'] >= 75:
            temp_context = f"üå°Ô∏è <span style='color: #FF6B35;'>{temp_display}</span>"
        elif hour['Temp'] <= 45:
            temp_context = f"‚ùÑÔ∏è <span style='color: #4FC3F7;'>{temp_display}</span>"
        else:
            temp_context = f"üå§Ô∏è <span style='color: #4CAF50;'>{temp_display}</span>"
    else:
        temp_context = f"üå°Ô∏è {temp_display}"
    
    # Color coding for wind - FIXED: Added N/A check
    if hour['Wind'] != "N/A":
        if hour['Wind'] > 15:
            wind_context = f"üí® <span style='color: #FF5722;'>{wind_display}</span>"
        elif hour['Wind'] <= 5:
            wind_context = f"üçÉ <span style='color: #4CAF50;'>{wind_display}</span>"
        else:
            wind_context = f"üí® {wind_display}"
    else:
        wind_context = f"üí® {wind_display}"
    
    # Color coding for precipitation - FIXED: Added N/A check
    if hour['Precip'] != "N/A":
        if hour['Precip'] > 30:
            precip_context = f"üåßÔ∏è <span style='color: #2196F3;'>{precip_display}</span> rain"
        elif hour['Precip'] > 10:
            precip_context = f"‚òÅÔ∏è <span style='color: #607D8B;'>{precip_display}</span> rain"
        elif hour['Precip'] > 0:
            precip_context = f"üå§Ô∏è <span style='color: #FFA726;'>{precip_display}</span> rain"
        else:
            precip_context = f"‚òÄÔ∏è <span style='color: #4CAF50;'>{precip_display}</span> rain"
    else:
        precip_context = f"üåßÔ∏è {precip_display} rain"
    
    # Color coding for humidity - FIXED: Added N/A check
    if hour['Humidity'] != "N/A":
        if hour['Humidity'] > 80:
            humidity_context = f"üíß <span style='color: #2196F3;'>{humidity_display}</span> humidity"
        elif hour['Humidity'] > 60:
            humidity_context = f"üíß <span style='color: #FF9800;'>{humidity_display}</span> humidity"
        else:
            humidity_context = f"üíß <span style='color: #4CAF50;'>{humidity_display}</span> humidity"
    else:
        humidity_context = f"üíß {humidity_display} humidity"
    
    return f"{temp_context} ‚Ä¢ {wind_context} ‚Ä¢ {precip_context} ‚Ä¢ {humidity_context}"

def _generate_dual_window_analysis_html(
    weather_data: dict,
    air_quality_forecast: str = "", 
    city: str = "Unknown City",
    today_start_hour: int = 6,
    today_end_hour: int = 10,
    tomorrow_start_hour: int = 18,
    tomorrow_end_hour: int = 22
) -> str:
    """Generate HTML analysis for dual time windows (today and tomorrow) - FIXED function scope."""
    
    logger.info(f"DUAL HTML DEBUG: Generating analysis for {city}")
    logger.info(f"DUAL HTML DEBUG: Today window: {today_start_hour}:00-{today_end_hour}:00")
    logger.info(f"DUAL HTML DEBUG: Tomorrow window: {tomorrow_start_hour}:00-{tomorrow_end_hour}:00")
    
    try:
        # Get today and tomorrow data from the parsed weather data
        today_data = weather_data.get('today', [])
        tomorrow_data = weather_data.get('tomorrow', [])
        
        logger.info(f"DUAL HTML DEBUG: Got {len(today_data)} today hours, {len(tomorrow_data)} tomorrow hours")
        
        if not today_data and not tomorrow_data:
            return "<div style='color: red; font-weight: bold;'>Cannot generate forecast: No weather data available</div>"

        # [... all the existing filtering and data processing code stays the same ...]
        
        # Filter today's data
        today_filtered = []
        for hour_data in today_data:
            hour_num = hour_data['HourNum']
            if hour_num != "N/A" and today_start_hour <= hour_num <= today_end_hour:
                today_filtered.append(hour_data)
        
        # Filter tomorrow's data
        tomorrow_filtered = []
        seen_hours = set()
        for hour_data in tomorrow_data:
            hour_num = hour_data['HourNum']
            hour_key = f"{hour_num}_{hour_data.get('Temp', 'N/A')}"
            
            if hour_key not in seen_hours and hour_num != "N/A" and tomorrow_start_hour <= hour_num <= tomorrow_end_hour:
                tomorrow_filtered.append(hour_data)
                seen_hours.add(hour_key)

        # Parse AQI data
        aqi_lines = [line.strip() for line in air_quality_forecast.split('\n') if line.strip()]
        today_aqi = "N/A"
        
        for line in aqi_lines:
            if '|' in line:
                parts = [part.strip() for part in line.split('|') if part.strip()]
                for part in parts:
                    aqi_match = re.search(r'\b(\d{1,3})\b', part)
                    if aqi_match:
                        potential_aqi = int(aqi_match.group(1))
                        if 0 <= potential_aqi <= 500:
                            today_aqi = potential_aqi
                            break
                if today_aqi != "N/A":
                    break

        # Score all hours using the FIXED scientific function
        today_scored = [score_hour_with_scientific_approach(hour, aqi_value=today_aqi) for hour in today_filtered]
        tomorrow_scored = [score_hour_with_scientific_approach(hour, aqi_value=today_aqi) for hour in tomorrow_filtered]
        
        # Sort by hour
        today_scored.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)
        tomorrow_scored.sort(key=lambda x: x['HourNum'] if x['HourNum'] != "N/A" else 0)

        # [... rest of HTML generation code ...]
        
        # Helper function to format time
        def format_time_12hour(hour_24):
            if hour_24 == 0:
                return "12:00 AM"
            elif hour_24 < 12:
                return f"{hour_24}:00 AM"
            elif hour_24 == 12:
                return "12:00 PM"
            else:
                return f"{hour_24 - 12}:00 PM"

        # Generate HTML header and recommendations sections...
        html = f"""
        <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 100%;">
            <!-- Header and recommendations HTML here -->
        """
        
        # TODAY'S HOURS - NOW USING MODULE-LEVEL render_hour_card FUNCTION
        if today_scored:
            date_display = get_formatted_date_display()
            html += f"""
                <div style="margin-top: 25px;">
                    <h2 style="margin: 10px 0; font-size: 16px; display: flex; align-items: center; flex-wrap: wrap;">
                        {date_display}
                       <strong style='font-size: 18px; color: #667eea;'>TODAY {format_time_12hour(today_start_hour)} TO {format_time_12hour(today_end_hour)} </strong> 
                    </h2>
            """
            for hour in today_scored:
                html += render_hour_card(hour, "#4CAF50", "#E8F5E8")  # This will now work
            html += '</div>'

        # TOMORROW'S HOURS - NOW USING MODULE-LEVEL render_hour_card FUNCTION
        if tomorrow_scored:
            date_display = get_formatted_tomorrow_date_display()
            html += f"""
                <div style="margin-top: 25px;">
                    <h2 style="margin: 10px 0; font-size: 16px; display: flex; align-items: center; flex-wrap: wrap;">
                        {date_display}
                       <strong style='font-size: 18px; color: #667eea;'> TOMORROW {format_time_12hour(tomorrow_start_hour)} TO {format_time_12hour(tomorrow_end_hour)}</strong> 
                    </h2>
            """
            for hour in tomorrow_scored:
                html += render_hour_card(hour, "#2196F3", "#E1F5FE")  # This will now work
            html += '</div>'
        
        # Footer
        html += """
            </div>
        """
        
        return html
        
    except Exception as e:
        logger.error(f"Error in dual window HTML analysis function: {e}")
        return f"<div style='color: red; font-weight: bold;'>Error generating analysis: {str(e)}</div>"

# --- Additional Helper Functions ---

def _generate_filtered_analysis(
    today_forecast: str = "", 
    tomorrow_forecast: str = "", 
    air_quality_forecast: str = "", 
    time_window: str = "today", 
    start_hour: int = None, 
    end_hour: int = None
) -> str:
    """Enhanced version that handles both today and tomorrow weather data with N/A handling."""
    city = "Unknown City"
    
    try:
        # Parse weather data from both days
        today_data = []
        tomorrow_data = []
        
        if today_forecast and "Error" not in today_forecast:
            parsed_data = parse_weather_data(today_forecast)
            today_data = parsed_data.get('today', [])
        
        if tomorrow_forecast and "Error" not in tomorrow_forecast:
            parsed_data = parse_weather_data(tomorrow_forecast)
            tomorrow_data = parsed_data.get('tomorrow', [])
        
        # Combine weather data
        all_weather_data = today_data + tomorrow_data
        
        if not all_weather_data:
            return "Cannot generate score: No weather data available"
        
        # Filter weather data by time range if specified
        weather_data = all_weather_data
        if start_hour is not None and end_hour is not None:
            weather_data = filter_weather_by_time_range(all_weather_data, start_hour, end_hour)
        
        if not weather_data:
            return f"No weather data found for the requested time window {start_hour}:00-{end_hour}:00"

        # Parse AQI data
        aqi_lines = [line.strip() for line in air_quality_forecast.split('\n') if line.strip()]
        today_aqi = "N/A"
        
        for line in aqi_lines:
            if '|' in line:
                parts = [part.strip() for part in line.split('|') if part.strip()]
                for part in parts:
                    aqi_match = re.search(r'\b(\d{1,3})\b', part)
                    if aqi_match:
                        potential_aqi = int(aqi_match.group(1))
                        if 0 <= potential_aqi <= 500:
                            today_aqi = potential_aqi
                            break
                if today_aqi != "N/A":
                    break

        # Generate scores for filtered data
        scored_hours = [score_hour_with_scientific_approach(hour_data, aqi_value=today_aqi) for hour_data in weather_data]

        # Sort hours chronologically
        def sort_key(hour_data):
            day_priority = 0 if hour_data['Day'] == 'today' else 1
            hour_num = hour_data['HourNum'] if hour_data['HourNum'] != "N/A" else 0
            return (day_priority, hour_num)
        
        scored_hours.sort(key=sort_key)
        
        # Generate formatted output
        lines = []
        lines.append("RUNNING FORECAST")
        lines.append(f"üìç {city}")
        lines.append(f"üå¨Ô∏è Air Quality: {today_aqi}")
        lines.append("")
        
        # Hourly breakdown
        for hour in scored_hours:
            # Use the pre-calculated final_score instead of the commented-out _map_risk_to_stars function
            risk_based_stars = hour.get('final_score', 3)  # Default to 3 if not available
            stars = "‚òÖ" * risk_based_stars + "‚òÜ" * (5 - risk_based_stars)
            temp_display = f"{hour['Temp']}¬∞F" if hour['Temp'] != "N/A" else "N/A"
            wind_display = f"{hour['Wind']}mph" if hour['Wind'] != "N/A" else "N/A"
            precip_display = f"{hour['Precip']}%" if hour['Precip'] != "N/A" else "N/A"
            
            lines.append(f"‚è∞ {hour['Hour']}")
            lines.append(f"   {stars} ({risk_based_stars}/5)")
            lines.append(f"   {temp_display} ‚Ä¢ {wind_display} ‚Ä¢ {precip_display}")
            lines.append("")
        
        lines.append("Have a great run!")
        return "\n".join(lines)
        
    except Exception as e:
        logger.error(f"Error in analysis function: {e}")
        return f"Error generating analysis: {str(e)}"

def _generate_filtered_analysis_html(
    today_forecast: str = "", 
    tomorrow_forecast: str = "", 
    air_quality_forecast: str = "", 
    time_window: str = "today", 
    start_hour: int = None, 
    end_hour: int = None
) -> str:
    """
    Stub for HTML output. Falls back to text output if not implemented.
    """
    return _generate_filtered_analysis(
        today_forecast=today_forecast,
        tomorrow_forecast=tomorrow_forecast,
        air_quality_forecast=air_quality_forecast,
        time_window=time_window,
        start_hour=start_hour,
        end_hour=end_hour
    )

# --- Agent Tools ---

@tool
def get_weather_forecast_from_server(city: str, granularity: str = 'hourly') -> str:
    """Gets the weather forecast (temp, wind, humidity, precip) for a city."""
    server_url = os.getenv("WEATHER_SERVER_URL", "http://localhost:8000/get_weather")
    payload = {"city": city, "granularity": granularity}
    headers = {"Content-Type": "application/json"}
    
    try:
        logger.info(f"Calling Weather Server for: {city} ({granularity})")
        response = requests.post(server_url, data=json.dumps(payload), headers=headers, timeout=30)
        response.raise_for_status()
        result = response.json()
        
        if "forecast" in result:
            return result["forecast"]
        else:
            return f"Weather data received but no forecast found for {city}"
            
    except requests.exceptions.Timeout:
        return f"Timeout error: Weather server took too long to respond for {city}"
    except requests.exceptions.ConnectionError:
        return f"Connection error: Could not connect to weather server for {city}"
    except requests.exceptions.RequestException as e:
        return f"Error contacting weather server for {city}: {e}"
    except json.JSONDecodeError:
        return f"Error: Invalid JSON response from weather server for {city}"

@tool
def get_air_quality_from_server(city: str) -> str:
    """Gets the Air Quality Index (AQI) forecast for a city."""
    server_url = os.getenv("AQI_SERVER_URL", "http://localhost:8001/get_air_quality")
    payload = {"city": city}
    headers = {"Content-Type": "application/json"}
    
    try:
        logger.info(f"Calling Air Quality Server for: {city}")
        response = requests.post(server_url, data=json.dumps(payload), headers=headers, timeout=30)
        response.raise_for_status()
        result = response.json()
        
        if "forecast" in result:
            return result["forecast"]
        else:
            return f"Air quality data received but no forecast found for {city}"
            
    except requests.exceptions.Timeout:
        return f"Timeout error: Air quality server took too long to respond for {city}"
    except requests.exceptions.ConnectionError:
        return f"Connection error: Could not connect to air quality server for {city}"
    except requests.exceptions.RequestException as e:
        return f"Error contacting air quality server for {city}: {e}"
    except json.JSONDecodeError:
        return f"Error: Invalid JSON response from air quality server for {city}"

@tool
def schedule_daily_email_report(
    city: str,
    today_start: str,
    today_end: str, 
    tomorrow_start: str,
    tomorrow_end: str,
    recipient_email: str,
    scheduled_time: str = "06:00"
) -> str:
    """Schedules a daily email report for dual time windows."""
    
    # Email validation pattern
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
    
    # Capture parameters in closure
    captured_city = city
    captured_today_start = today_start
    captured_today_end = today_end
    captured_tomorrow_start = tomorrow_start
    captured_tomorrow_end = tomorrow_end
    
    logger.info(f"SCHEDULING DUAL: {city}, Today: {today_start}-{today_end}, Tomorrow: {tomorrow_start}-{tomorrow_end}")
    
    def job():
        logger.info(f"Running scheduled dual window job for {captured_city}")
        try:
            # Generate HTML report
            analysis = run_agent_workflow(
                city=captured_city,
                today_start=captured_today_start,
                today_end=captured_today_end,
                tomorrow_start=captured_tomorrow_start,
                tomorrow_end=captured_tomorrow_end,
                output_format="html"
            )
            
            subject = f"Your Daily Running Forecast for {captured_city}"
            
            # Email HTML structure
            html_body = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 20px; background-color: #f9f9f9; }}
                    .email-container {{ max-width: 600px; margin: 0 auto; background: white; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }}
                    .email-footer {{ margin-top: 30px; padding: 20px; text-align: center; color: #666; background: #f5f5f5; }}
                </style>
            </head>
            <body>
                <div class="email-container">
                    {analysis}
                    <div class="email-footer">
                        <p style="margin: 0;"><small>This is an automated report. Reply if you need assistance.</small></p>
                    </div>
                </div>
            </body>
            </html>
            """
            
            if send_email_notification(recipient_email, subject, html_body, is_html=True):
                logger.info(f"Successfully sent dual window scheduled report to {recipient_email}")
            else:
                logger.error(f"Failed to send dual window scheduled report to {recipient_email}")
                
        except Exception as e:
            logger.error(f"Error in dual window scheduled job: {e}")

    if not re.match(email_pattern, recipient_email):
        return f"Error: Invalid email address format: {recipient_email}"
    
    try:
        datetime.strptime(scheduled_time, "%H:%M")
    except ValueError:
        return f"Error: Invalid time format. Please use HH:MM format (e.g., '06:00')"
    
    try:
        schedule.every().day.at(scheduled_time).do(job)
        return f"‚úÖ Success! Daily running report for '{city}' scheduled for {scheduled_time} to '{recipient_email}'. Time windows: Today {today_start}-{today_end}, Tomorrow {tomorrow_start}-{tomorrow_end}"
    except Exception as e:
        return f"Error scheduling email report: {e}"

# --- Agent and Graph Definitions ---

class AgentState(TypedDict):
    messages: Annotated[list[BaseMessage], operator.add]
    city: str
    time_window: str
    weather_data: str
    aqi_data: str

def run_agent_workflow(
    city: str,
    today_start: str,
    today_end: str,
    tomorrow_start: str,
    tomorrow_end: str,
    output_format: str = "html"
) -> str:
    """Updated workflow function for dual time windows - CORRECTED."""
    try:
        # Extract parameters for dual windows
        params = extract_dual_query_parameters(city, today_start, today_end, tomorrow_start, tomorrow_end)
        
        logger.info(f"Dual window workflow - City: {city}")
        logger.info(f"Today: {today_start} to {today_end}")
        logger.info(f"Tomorrow: {tomorrow_start} to {tomorrow_end}")
        
        # Get weather data - CORRECTED: Single call that returns 48 hours
        weather_response = get_weather_forecast_from_server.invoke({"city": city, "granularity": "hourly"})
        aqi_data = get_air_quality_from_server.invoke({"city": city})
        
        # Parse the weather data - CORRECTED: Parse once and split into today/tomorrow
        weather_data = parse_weather_data(weather_response)
        
        logger.info(f"Retrieved and parsed weather data: {len(weather_data['today'])} today hours, {len(weather_data['tomorrow'])} tomorrow hours")
        
        # Generate analysis using the dual window function
        if output_format.lower() == "html":
            analysis = _generate_dual_window_analysis_html(
                weather_data=weather_data,
                air_quality_forecast=aqi_data,
                city=city,
                today_start_hour=params['today_start_hour'],
                today_end_hour=params['today_end_hour'],
                tomorrow_start_hour=params['tomorrow_start_hour'],
                tomorrow_end_hour=params['tomorrow_end_hour']
            )
        else:
            # For text format
            analysis = _generate_dual_window_analysis_text(
                weather_data=weather_data,
                air_quality_forecast=aqi_data,
                city=city,
                today_start_hour=params['today_start_hour'],
                today_end_hour=params['today_end_hour'],
                tomorrow_start_hour=params['tomorrow_start_hour'],
                tomorrow_end_hour=params['tomorrow_end_hour']
            )
        
        return analysis
        
    except Exception as e:
        logger.error(f"Dual window workflow error: {e}")
        return f"Error in agent workflow: {str(e)}. Please check your configuration and try again."

def _generate_dual_window_analysis_text(
    weather_data: dict,
    air_quality_forecast: str = "", 
    city: str = "Unknown City",
    today_start_hour: int = 6,
    today_end_hour: int = 10,
    tomorrow_start_hour: int = 18,
    tomorrow_end_hour: int = 22
) -> str:
    """Generate text analysis for dual time windows - CORRECTED."""
    
    try:
        # Get today and tomorrow data from the parsed weather data
        today_data = weather_data.get('today', [])
        tomorrow_data = weather_data.get('tomorrow', [])
        
        if not today_data and not tomorrow_data:
            return "Cannot generate forecast: No weather data available"

        # Filter data for time windows
        today_filtered = [h for h in today_data if h['HourNum'] != "N/A" and today_start_hour <= h['HourNum'] <= today_end_hour]
        tomorrow_filtered = [h for h in tomorrow_data if h['HourNum'] != "N/A" and tomorrow_start_hour <= h['HourNum'] <= tomorrow_end_hour]

        # Parse AQI
        aqi_lines = [line.strip() for line in air_quality_forecast.split('\n') if line.strip()]
        today_aqi = "N/A"
        for line in aqi_lines:
            if '|' in line:
                parts = [part.strip() for part in line.split('|') if part.strip()]
                for part in parts:
                    aqi_match = re.search(r'\b(\d{1,3})\b', part)
                    if aqi_match:
                        potential_aqi = int(aqi_match.group(1))
                        if 0 <= potential_aqi <= 500:
                            today_aqi = potential_aqi
                            break
                if today_aqi != "N/A":
                    break

        # Score hours
        today_scored = [score_hour_with_scientific_approach(h, aqi_value=today_aqi) for h in today_filtered]
        tomorrow_scored = [score_hour_with_scientific_approach(h, aqi_value=today_aqi) for h in tomorrow_filtered]
        
        # Find best hours
        best_today = max(today_scored, key=lambda x: x['score_100']) if today_scored else None
        best_tomorrow = max(tomorrow_scored, key=lambda x: x['score_100']) if tomorrow_scored else None

        # Generate text output
        lines = []
        lines.append("RUNNING FORECAST")
        lines.append(f"Location: {city}")
        lines.append("")
        
        if best_today:
            lines.append("BEST TIME TODAY:")
            lines.append(f"  {best_today['Hour']} - Perfect conditions!")
            temp_str = f"{best_today['Temp']}¬∞F" if best_today['Temp'] != "N/A" else "N/A"
            wind_str = f"{best_today['Wind']}mph" if best_today['Wind'] != "N/A" else "N/A" 
            precip_str = f"{best_today['Precip']}%" if best_today['Precip'] != "N/A" else "N/A"
            humidity_str = f"{best_today['Humidity']}%" if best_today['Humidity'] != "N/A" else "N/A"
            lines.append(f"  {temp_str}, {wind_str} wind, {precip_str} rain, {humidity_str} humidity")
        
        if best_tomorrow:
            lines.append("")
            lines.append("BEST TIME TOMORROW:")
            lines.append(f"  {best_tomorrow['Hour']} - Great choice!")
            temp_str = f"{best_tomorrow['Temp']}¬∞F" if best_tomorrow['Temp'] != "N/A" else "N/A"
            wind_str = f"{best_tomorrow['Wind']}mph" if best_tomorrow['Wind'] != "N/A" else "N/A"
            precip_str = f"{best_tomorrow['Precip']}%" if best_tomorrow['Precip'] != "N/A" else "N/A"
            humidity_str = f"{best_tomorrow['Humidity']}%" if best_tomorrow['Humidity'] != "N/A" else "N/A"
            lines.append(f"  {temp_str}, {wind_str} wind, {precip_str} rain, {humidity_str} humidity")
        
        lines.append("")
        lines.append("Have a great run!")
        
        return "\n".join(lines)
        
    except Exception as e:
        return f"Error generating text analysis: {str(e)}"

def run_scheduler():
    """Run the email scheduler in a separate thread."""
    while True:
        schedule.run_pending()
        time.sleep(60)

def start_scheduler():
    """Start the email scheduler in background."""
    scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
    scheduler_thread.start()
    logger.info("Email scheduler started")

def main():
    """Main function for testing the system."""
    print("Running Forecast System Initialized")
    print("Available commands:")
    print("1. Get running forecast: 'What's the best time to run in [city]?'")
    print("2. Time-specific queries: 'Best time to run between 8AM and 11AM in NYC?'")
    print("3. Cross-day queries: 'Running conditions from 4PM today to 11AM tomorrow in Boston?'")
    print("4. Schedule daily emails: Use the schedule_daily_email_report tool")
    print("5. Type 'quit' to exit")
    
    start_scheduler()
    
    while True:
        try:
            user_input = input("\nEnter your query: ").strip()
            if user_input.lower() in ['quit', 'exit', 'q']:
                break
                
            if user_input:
                print("\nProcessing your request...\n")
                # For testing, use sample dual window parameters
                result = run_agent_workflow(
                    city="New York",
                    today_start="06:00",
                    today_end="10:00", 
                    tomorrow_start="18:00",
                    tomorrow_end="22:00",
                    output_format="text"
                )
                print("Result:")
                print("=" * 50)
                print(result)
                print("=" * 50)
            
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    main()